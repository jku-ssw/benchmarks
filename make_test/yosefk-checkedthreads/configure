#!/usr/bin/python
import commands, os

for dir in 'obj lib bin'.split():
    os.system('mkdir -p '+dir)

def compiles_and_runs(compiler_cmd,run_cmd,expected_output_substr):
    andcmd = compiler_cmd + ' && ' + run_cmd
    print ' ',andcmd
    return expected_output_substr in commands.getoutput(andcmd)

features = {
    'C++11':
        dict(compile='g++ -o bin/cfg_cpp11 cfg/cpp11.cpp -std=c++0x',
             run='./bin/cfg_cpp11',
             define='CT_CXX11'),
    'OpenMP':
        dict(compile='gcc -o bin/cfg_openmp cfg/openmp.c -fopenmp',
             run='./bin/cfg_openmp',
             define='CT_OPENMP'),
    'TBB':
        dict(compile='g++ -o bin/cfg_tbb cfg/tbb.cpp -ltbb',
             run='./bin/cfg_tbb',
             define='CT_TBB'), 
    'pthreads':
        dict(compile='gcc -o bin/cfg_pthreads cfg/pthreads.c -pthread',
             run='./bin/cfg_pthreads',
             define='CT_PTHREADS'),
}

available = []
for feature,attrs in sorted(features.items()):
    print 'checking for',feature,'availability...'
    expected_output_substr = feature + ' test passed'
    if compiles_and_runs(attrs['compile'],attrs['run'],expected_output_substr):
        print feature,'available: yes'
        available.append(feature)
    else:
        print feature,'available: no'
    print

config_header = ['/* auto-generated by the configure script; can be edited manually if configure got it wrong... */']
for feature,attrs in sorted(features.items()):
    flag = attrs['define']
    if feature in available:
        config_header.append('#define %s /* enable %s */'%(flag,feature))
    else:
        config_header.append('/* #define %s - uncomment to enable %s */'%(flag,feature))

cfgh = 'include/checkedthreads_config.h'
open(cfgh,'w').write('\n'.join(config_header)+'\n')
